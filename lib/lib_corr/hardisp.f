      program hardisp
c
      parameter (nl=600)
      parameter (nt=342)
      parameter (ntin=11)
c
c    Reads in a file of station displacements in the BLQ format used by Scherneck
c  and Bos for ocean loading, and outputs a time series of computed
c  tidal displacments, using an expanded set of tidal constituents, whose
c  amplitudes and phases are found by spline interpolation of the tidal
c  admittance.  A total of 342 constituent tides are included, which gives
c  a precision of about 0.1%
c
c  See format statement 100, below, for a summary of usage
c
c    Duncan Agnew, August 2005, based on the program   hartid  distributed
c  with the SPOTL loading package.
c
c  Corrected Nov 2005 (error in reading displacements)
c  Revised   Dec 2005 (Hartmann-Wenzel harmonics in admint)
c     GP  17 Dec 2007 Corrected 'intial' to 'initial' (noted by T. Springer)
c  Revised   Jun 2008 Corrected long-period tides, modernized control flow,
c                     added explicit typing; increased number of
c                     harmonics and added one decimal to their amplitudes
c     GP  16 Feb 2009 Updated for 2009.0 leap second
c     GP  10 Apr 2009 Added the IERS Conventions license
c
c+++++++++++++++++++++++++++++++++++++++++++
c
c    NOTE: The st & si arrays and parameter nstep, in subroutine etutc, must be
c  updated for new leap seconds; currently complete through 2009.5.
c
c+++++++++++++++++++++++++++++++++++++++++++
c
c    **calls admint,tdfrph,recurs,spline,shells
c
c    Validation test data using hardisp.f routine:
c  Test made by Duncan Agnew using g77 compiler on Mac OSX 10.3.9
c
c  Input ocean loading coefficients were generated by the ocean loading
c  service on 30 January 2006 using http://www.oso.chalmers.se/~loading/
c  for IGS station BRST using the CSR4.0 model and "NO" geocenter correction:
c
c  BRST
c$$ CSR4.0_f_PP ID: Jan  30, 2006 15:51
c$$ Computed by OLMPP by H G Scherneck, Onsala Space Observatory, 2006
c$$ BRST,                                RADI TANG lon/lat:  355.5034   48.3805
c  .03979 .01305 .00822 .00338 .00440 .00225 .00144 .00057 .00066 .00034 .00030
c  .00876 .00289 .00186 .00075 .00068 .00051 .00023 .00015 .00006 .00002 .00003
c  .00633 .00263 .00137 .00071 .00041 .00033 .00014 .00010 .00004 .00002 .00001
c   -61.9  -25.3  -81.5  -21.9  -72.3  160.2  -78.0  105.6    9.1    6.1    1.6
c    97.2  131.1   76.9  133.7   91.2  -13.8   84.0  -67.1 -171.4 -165.9 -178.5
c    32.6   65.9   18.4   68.3   20.7  -91.1    8.5 -156.8  -15.8   -3.3   -0.8
c
c  The hardisp routine was executed with the following command and with the
c  six lines of coefficients above input from standard input.  In other words,
c  BRST site displacements were computed for epoch 2006 01 01 00h 00m 00s and
c  for each of the following 23 hours.  The output given below was written to
c  standard output in units of meters with the format 3F14.6:
c         dU    dS    dW
c
c> hardisp 2006 1 1 0 0 0 24 3600
c
c      0.039868      0.005599     -0.005165
c      0.016768      0.008627      0.000864
c     -0.011545      0.009595      0.006925
c     -0.038218      0.008229      0.011528
c     -0.056729      0.004834      0.013526
c     -0.062519      0.000224      0.012412
c     -0.054139     -0.004479      0.008442
c     -0.033621     -0.008126      0.002578
c     -0.005975     -0.009829     -0.003754
c      0.022057     -0.009184     -0.009016
c      0.043685     -0.006368     -0.011946
c      0.053761     -0.002102     -0.011869
c      0.050069      0.002539     -0.008866
c      0.033858      0.006392     -0.003750
c      0.009523      0.008502      0.002139
c     -0.016528      0.008360      0.007277
c     -0.037498      0.006032      0.010342
c     -0.047934      0.002140      0.010549
c     -0.045110     -0.002293      0.007848
c     -0.029729     -0.006108      0.002941
c     -0.005752     -0.008304     -0.002900
c      0.020605     -0.008289     -0.008149
c      0.042443     -0.006039     -0.011419
c      0.053932     -0.002099     -0.011812
c
c+++++++++++++++++++++++++++++++++++++++++++
c
c  Parameters below set the buffer size for computing the tides
c  recursively (nl), the number of harmonics used in the prediction
c  (nt; this must also be set in the subroutine admint) and the number
c  of harmonics read in (ntin)
c
c+++++++++++++++++++++++++++++++++++++++++++
c
      character*40 dumm
      integer i,iday,idt,imonth,irhi,irli,it,luo,nb,nl,np,nt,ntin
      real amp,as,aw,az,ds,dw,dz,hcs,hcw,hcz,phase,tamp,tph,wf
      double precision f,pz,ps,pw,scr
      double precision dr,pi
c
      dimension tamp(3,ntin),tph(3,ntin)
      dimension idt(6,ntin),amp(ntin),phase(ntin)
      dimension az(nt),pz(nt),hcz(2*nt)
      dimension as(nt),ps(nt),hcs(2*nt)
      dimension aw(nt),pw(nt),hcw(2*nt)
      dimension dz(nl),ds(nl),dw(nl)
      dimension f(nt),scr(3*nt),wf(nt)
      common/date/it(5)
      data dr/.01745329252d0/,pi/3.1415926535898d0/,irli/1/
      data luo/6/
c
c  Cartwright-Tayler numbers of tides used in Scherneck lists:
c      M2, S2, N2, K2, K1, O1, P1, Q1, Mf, Mm, Ssa
c
      data idt/
     1  2, 0, 0, 0, 0, 0,   2, 2,-2, 0, 0, 0,   2,-1, 0, 1, 0, 0,
     2  2, 2, 0, 0, 0, 0,   1, 1, 0, 0, 0, 0,   1,-1, 0, 0, 0, 0,
     3  1, 1,-2, 0, 0, 0,   1,-2, 0, 1, 0, 0,   0, 2, 0, 0, 0, 0,
     4  0, 1, 0,-1, 0, 0,   0, 0, 2, 0, 0, 0/
c*******************************************************************
c
c  check number of arguments from command line, then read them in
c
c*******************************************************************
      if(iargc().lt.7.or.iargc().gt.8) then
        write(luo,100)
 100    format(/,'Usage:',/,
     1  '   hardisp yr [d-of-yr | month day] hr min sec num samp',//,
     1  ' Where ',/,
     2  '   the UTC date given is the time of the first term output',/,
     4  '   num is the number of output epochs to be written out',/,
     3  '   samp is the sample interval (seconds)',//,
     5  '  The harmonics file (amp and phase of displacement) is ',/,
     6  '    read from standard input in the BLQ format used by  ',/,
     6  '    Scherneck and Bos                                   ',//,
     8  '  Results are written to standard output (units = m):',/,
     9  '      dU    dS    dW   ',/,
     1  '    using format: 3F14.6 ',/)
        stop
      endif
      call getarg(1,dumm)
      read(dumm,102) it(1)
 102  format(i4)
      if(iargc().eq.7) then
        call getarg(2,dumm)
        read(dumm,102) it(2)
        nb=0
      endif
      if(iargc().eq.8) then
        call getarg(2,dumm)
        read(dumm,102) imonth
        call getarg(3,dumm)
        read(dumm,102) iday
        nb=1
        it(2) = iday + mday(it(1),imonth)
      endif
      call getarg(nb+3,dumm)
      read(dumm,102) it(3)
      call getarg(nb+4,dumm)
      read(dumm,102) it(4)
      call getarg(nb+5,dumm)
      read(dumm,102) it(5)
      call getarg(nb+6,dumm)
      read(dumm,104) irnt
 104  format(i6)
      call getarg(nb+7,dumm)
      read(dumm,106) samp
 106  format(f7.0)
c*******************************************************************
c
c    read in amplitudes and phases, in standard "Scherneck" form, from
c  standard input
c
c*******************************************************************
      do i=1,3
        read(5,108) (tamp(i,kk),kk=1,ntin)
 108    format(1x,11f7.5)
      enddo
      do i=1,3
        read(5,110) (tph(i,kk),kk=1,ntin)
 110    format(1x,11f7.1)
c
c   change sign for phase, to be negative for lags
c
        do kk=1,ntin
          tph(i,kk)=-tph(i,kk)
        enddo
      enddo
c*******************************************************************
c
c    find amplitudes and phases for all constituents, for each of the
c  three displacements. Note that the same frequencies are returned each
c  time
c    BLQ format order is vertical, horizontal EW, horizontal NS
c
c*******************************************************************
      do i=1,ntin
        amp(i)=tamp(1,i)
        phase(i)=tph(1,i)
      enddo
      call admint(amp,idt,phase,az,f,pz,ntin,ntout)
      do i=1,ntin
        amp(i)=tamp(2,i)
        phase(i)=tph(2,i)
      enddo
      call admint(amp,idt,phase,aw,f,pw,ntin,ntout)
      do i=1,ntin
        amp(i)=tamp(3,i)
        phase(i)=tph(3,i)
      enddo
      call admint(amp,idt,phase,as,f,ps,ntin,ntout)
c
c    set up for recursion, by normalizing frequencies, and converting
c  phases to radians
c
      do i=1,ntout
        pz(i) = dr*pz(i)
        ps(i) = dr*ps(i)
        pw(i) = dr*pw(i)
        f(i) = samp*pi*f(i)/43200.d0
        wf(i) = f(i)
      enddo
c*******************************************************************
c
c    Loop over times, nl output points at a time. At the start of each
c  such block, convert from amp and phase to sin and cos (hc array) at
c  the start of the block. The computation of values within each
c  block is done recursively, since the times are equi-spaced.
c
c*******************************************************************

 11   irhi = min(irli+nl-1,irnt)
      np = irhi - irli + 1
c  set up harmonic coefficients, compute tide, and write out
      do i=1,nt
        hcz(2*i-1) = az(i)*dcos(pz(i))
        hcz(2*i)  = -az(i)*dsin(pz(i))
        hcs(2*i-1) = as(i)*dcos(ps(i))
        hcs(2*i)  = -as(i)*dsin(ps(i))
        hcw(2*i-1) = aw(i)*dcos(pw(i))
        hcw(2*i)  = -aw(i)*dsin(pw(i))
      enddo
      call recurs(dz,np,hcz,ntout,wf,scr)
      call recurs(ds,np,hcs,ntout,wf,scr)
      call recurs(dw,np,hcw,ntout,wf,scr)
      write(luo,120) (dz(i),ds(i),dw(i),i=1,np)
 120  format(3f14.6)
      if(irhi.eq.irnt) stop
      irli = irhi + 1
c  reset phases to the start of the new section
      do i=1,nt
        pz(i) = dmod(pz(i) + np*f(i),2.d0*pi)
        ps(i) = dmod(ps(i) + np*f(i),2.d0*pi)
        pw(i) = dmod(pw(i) + np*f(i),2.d0*pi)
      enddo
      go to 11
      end
c
c=============================================================================
c
      subroutine admint(ampin,idtin,phin,amp,f,p,nin,nout)
c
c    Returns the amplitude, frequency, and phase of a set of tidal
c  constituents. n is input as the number wanted, and returned as the number
c  provided.  The constituents used are stored in the arrays idd (doodson
c  number) and tamp (Cartwright-Edden amplitude).  The actual amp and
c  phase of each of these are determined by spline interpolation of the
c  real and imaginary part of the admittance, as specified at a subset
c  of the constituents.
c    The phase is determined for a time set in common block /date/ (see
c  subroutine tdfrph), outside of this subroutine.
c
c  Note that the arrays f and p must be specified as double precision.
c
c  $$$$calls tdfrph,spline,eval,shells
c
c    Parameters below set the number of harmonics used in the prediction
c  (nt; this must also be set in the main program) and the number of
c  constituents whose amp and phase may be specified (ncon)
c
      parameter (nt=342)
      parameter (ncon=20)
      integer i,idd,idtin,j,k,key,ll,ncon,ndi,nin,nlp,nout,nsd,nt
      real aim,amp,ampin,di,dr,dtr,phin,rf,rl,scr,sdi,sdr,tamp,zdi,zdr
      double precision f,fr,p,pr
c
      dimension ampin(*),idtin(6,*),phin(*)
      dimension amp(*),f(*),p(*)
c  arrays containing information about all stored constituents
      dimension idd(6,nt),tamp(nt)
c  arrays containing information about the subset whose amp and phase may
c  be specified, and scratch arrays for the spline routines
c   at most ncon constituents may be specified.
      dimension rl(ncon),aim(ncon),rf(ncon),key(ncon),scr(ncon),
     1 zdi(ncon),zdr(ncon),di(ncon),dr(ncon),sdi(ncon),sdr(ncon)
      data dtr/.01745329252/
      data rl/ncon*0.0/,aim/ncon*0.0/,rf/ncon*0.0/
      data zdi/ncon*0.0/,zdr/ncon*0.0/,di/ncon*0.0/,dr/ncon*0.0/
      data sdi/ncon*0.0/,sdr/ncon*0.0/
      data tamp/
     1  .632208, .294107, .121046, .079915, .023818,-.023589, .022994,
     2  .019333,-.017871, .017192, .016018, .004671,-.004662,-.004519,
     3  .004470, .004467, .002589,-.002455,-.002172, .001972, .001947,
     4  .001914,-.001898, .001802, .001304, .001170, .001130, .001061,
     5 -.001022,-.001017, .001014, .000901,-.000857, .000855, .000855,
     6  .000772, .000741, .000741,-.000721, .000698, .000658, .000654,
     7 -.000653, .000633, .000626,-.000598, .000590, .000544, .000479,
     8 -.000464, .000413,-.000390, .000373, .000366, .000366,-.000360,
     9 -.000355, .000354, .000329, .000328, .000319, .000302, .000279,
     1 -.000274,-.000272, .000248,-.000225, .000224,-.000223,-.000216,
     2  .000211, .000209, .000194, .000185,-.000174,-.000171, .000159,
     3  .000131, .000127, .000120, .000118, .000117, .000108, .000107,
     4  .000105,-.000102, .000102, .000099,-.000096, .000095,-.000089,
     5 -.000085,-.000084,-.000081,-.000077,-.000072,-.000067, .000066,
     6  .000064, .000063, .000063, .000063, .000062, .000062,-.000060,
     7  .000056, .000053, .000051, .000050, .368645,-.262232,-.121995,
     8 -.050208, .050031,-.049470, .020620, .020613, .011279,-.009530,
     9 -.009469,-.008012, .007414,-.007300, .007227,-.007131,-.006644,
     1  .005249, .004137, .004087, .003944, .003943, .003420, .003418,
     2  .002885, .002884, .002160,-.001936, .001934,-.001798, .001690,
     3  .001689, .001516, .001514,-.001511, .001383, .001372, .001371,
     4 -.001253,-.001075, .001020, .000901, .000865,-.000794, .000788,
     5  .000782,-.000747,-.000745, .000670,-.000603,-.000597, .000542,
     6  .000542,-.000541,-.000469,-.000440, .000438, .000422, .000410,
     7 -.000374,-.000365, .000345, .000335,-.000321,-.000319, .000307,
     8  .000291, .000290,-.000289, .000286, .000275, .000271, .000263,
     9 -.000245, .000225, .000225, .000221,-.000202,-.000200,-.000199,
     1  .000192, .000183, .000183, .000183,-.000170, .000169, .000168,
     2  .000162, .000149,-.000147,-.000141, .000138, .000136, .000136,
     3  .000127, .000127,-.000126,-.000121,-.000121, .000117,-.000116,
     4 -.000114,-.000114,-.000114, .000114, .000113, .000109, .000108,
     5  .000106,-.000106,-.000106, .000105, .000104,-.000103,-.000100,
     6 -.000100,-.000100, .000099,-.000098, .000093, .000093, .000090,
     7 -.000088, .000083,-.000083,-.000082,-.000081,-.000079,-.000077,
     8 -.000075,-.000075,-.000075, .000071, .000071,-.000071, .000068,
     9  .000068, .000065, .000065, .000064, .000064, .000064,-.000064,
     1 -.000060, .000056, .000056, .000053, .000053, .000053,-.000053,
     2  .000053, .000053, .000052, .000050,-.066607,-.035184,-.030988,
     3  .027929,-.027616,-.012753,-.006728,-.005837,-.005286,-.004921,
     4 -.002884,-.002583,-.002422, .002310, .002283,-.002037, .001883,
     5 -.001811,-.001687,-.001004,-.000925,-.000844, .000766, .000766,
     6 -.000700,-.000495,-.000492, .000491, .000483, .000437,-.000416,
     7 -.000384, .000374,-.000312,-.000288,-.000273, .000259, .000245,
     8 -.000232, .000229,-.000216, .000206,-.000204,-.000202, .000200,
     9  .000195,-.000190, .000187, .000180,-.000179, .000170, .000153,
     1 -.000137,-.000119,-.000119,-.000112,-.000110,-.000110, .000107,
     2 -.000095,-.000095,-.000091,-.000090,-.000081,-.000079,-.000079,
     3  .000077,-.000073, .000069,-.000067,-.000066, .000065, .000064,
     4 -.000062, .000060, .000059,-.000056, .000055,-.000051/
      data idd/
     1  2, 0, 0, 0, 0, 0,   2, 2,-2, 0, 0, 0,   2,-1, 0, 1, 0, 0,  
     2  2, 2, 0, 0, 0, 0,   2, 2, 0, 0, 1, 0,   2, 0, 0, 0,-1, 0,  
     3  2,-1, 2,-1, 0, 0,   2,-2, 2, 0, 0, 0,   2, 1, 0,-1, 0, 0,  
     4  2, 2,-3, 0, 0, 1,   2,-2, 0, 2, 0, 0,   2,-3, 2, 1, 0, 0,  
     5  2, 1,-2, 1, 0, 0,   2,-1, 0, 1,-1, 0,   2, 3, 0,-1, 0, 0,  
     6  2, 1, 0, 1, 0, 0,   2, 2, 0, 0, 2, 0,   2, 2,-1, 0, 0,-1,  
     7  2, 0,-1, 0, 0, 1,   2, 1, 0, 1, 1, 0,   2, 3, 0,-1, 1, 0,  
     8  2, 0, 1, 0, 0,-1,   2, 0,-2, 2, 0, 0,   2,-3, 0, 3, 0, 0,  
     9  2,-2, 3, 0, 0,-1,   2, 4, 0, 0, 0, 0,   2,-1, 1, 1, 0,-1,  
     1  2,-1, 3,-1, 0,-1,   2, 2, 0, 0,-1, 0,   2,-1,-1, 1, 0, 1,  
     2  2, 4, 0, 0, 1, 0,   2,-3, 4,-1, 0, 0,   2,-1, 2,-1,-1, 0,  
     3  2, 3,-2, 1, 0, 0,   2, 1, 2,-1, 0, 0,   2,-4, 2, 2, 0, 0,  
     4  2, 4,-2, 0, 0, 0,   2, 0, 2, 0, 0, 0,   2,-2, 2, 0,-1, 0,  
     5  2, 2,-4, 0, 0, 2,   2, 2,-2, 0,-1, 0,   2, 1, 0,-1,-1, 0,  
     6  2,-1, 1, 0, 0, 0,   2, 2,-1, 0, 0, 1,   2, 2, 1, 0, 0,-1,  
     7  2,-2, 0, 2,-1, 0,   2,-2, 4,-2, 0, 0,   2, 2, 2, 0, 0, 0,  
     8  2,-4, 4, 0, 0, 0,   2,-1, 0,-1,-2, 0,   2, 1, 2,-1, 1, 0,  
     9  2,-1,-2, 3, 0, 0,   2, 3,-2, 1, 1, 0,   2, 4, 0,-2, 0, 0,  
     1  2, 0, 0, 2, 0, 0,   2, 0, 2,-2, 0, 0,   2, 0, 2, 0, 1, 0,  
     2  2,-3, 3, 1, 0,-1,   2, 0, 0, 0,-2, 0,   2, 4, 0, 0, 2, 0,  
     3  2, 4,-2, 0, 1, 0,   2, 0, 0, 0, 0, 2,   2, 1, 0, 1, 2, 0,  
     4  2, 0,-2, 0,-2, 0,   2,-2, 1, 0, 0, 1,   2,-2, 1, 2, 0,-1,  
     5  2,-1, 1,-1, 0, 1,   2, 5, 0,-1, 0, 0,   2, 1,-3, 1, 0, 1,  
     6  2,-2,-1, 2, 0, 1,   2, 3, 0,-1, 2, 0,   2, 1,-2, 1,-1, 0,  
     7  2, 5, 0,-1, 1, 0,   2,-4, 0, 4, 0, 0,   2,-3, 2, 1,-1, 0,  
     8  2,-2, 1, 1, 0, 0,   2, 4, 0,-2, 1, 0,   2, 0, 0, 2, 1, 0,  
     9  2,-5, 4, 1, 0, 0,   2, 0, 2, 0, 2, 0,   2,-1, 2, 1, 0, 0,  
     1  2, 5,-2,-1, 0, 0,   2, 1,-1, 0, 0, 0,   2, 2,-2, 0, 0, 2,  
     2  2,-5, 2, 3, 0, 0,   2,-1,-2, 1,-2, 0,   2,-3, 5,-1, 0,-1,  
     3  2,-1, 0, 0, 0, 1,   2,-2, 0, 0,-2, 0,   2, 0,-1, 1, 0, 0,  
     4  2,-3, 1, 1, 0, 1,   2, 3, 0,-1,-1, 0,   2, 1, 0, 1,-1, 0,  
     5  2,-1, 2, 1, 1, 0,   2, 0,-3, 2, 0, 1,   2, 1,-1,-1, 0, 1,  
     6  2,-3, 0, 3,-1, 0,   2, 0,-2, 2,-1, 0,   2,-4, 3, 2, 0,-1,  
     7  2,-1, 0, 1,-2, 0,   2, 5, 0,-1, 2, 0,   2,-4, 5, 0, 0,-1,  
     8  2,-2, 4, 0, 0,-2,   2,-1, 0, 1, 0, 2,   2,-2,-2, 4, 0, 0,  
     9  2, 3,-2,-1,-1, 0,   2,-2, 5,-2, 0,-1,   2, 0,-1, 0,-1, 1,  
     1  2, 5,-2,-1, 1, 0,   1, 1, 0, 0, 0, 0,   1,-1, 0, 0, 0, 0,  
     2  1, 1,-2, 0, 0, 0,   1,-2, 0, 1, 0, 0,   1, 1, 0, 0, 1, 0,  
     3  1,-1, 0, 0,-1, 0,   1, 2, 0,-1, 0, 0,   1, 0, 0, 1, 0, 0,  
     4  1, 3, 0, 0, 0, 0,   1,-2, 2,-1, 0, 0,   1,-2, 0, 1,-1, 0,  
     5  1,-3, 2, 0, 0, 0,   1, 0, 0,-1, 0, 0,   1, 1, 0, 0,-1, 0,  
     6  1, 3, 0, 0, 1, 0,   1, 1,-3, 0, 0, 1,   1,-3, 0, 2, 0, 0,  
     7  1, 1, 2, 0, 0, 0,   1, 0, 0, 1, 1, 0,   1, 2, 0,-1, 1, 0,  
     8  1, 0, 2,-1, 0, 0,   1, 2,-2, 1, 0, 0,   1, 3,-2, 0, 0, 0,  
     9  1,-1, 2, 0, 0, 0,   1, 1, 1, 0, 0,-1,   1, 1,-1, 0, 0, 1,  
     1  1, 4, 0,-1, 0, 0,   1,-4, 2, 1, 0, 0,   1, 0,-2, 1, 0, 0,  
     2  1,-2, 2,-1,-1, 0,   1, 3, 0,-2, 0, 0,   1,-1, 0, 2, 0, 0,  
     3  1,-1, 0, 0,-2, 0,   1, 3, 0, 0, 2, 0,   1,-3, 2, 0,-1, 0,  
     4  1, 4, 0,-1, 1, 0,   1, 0, 0,-1,-1, 0,   1, 1,-2, 0,-1, 0,  
     5  1,-3, 0, 2,-1, 0,   1, 1, 0, 0, 2, 0,   1, 1,-1, 0, 0,-1,  
     6  1,-1,-1, 0, 0, 1,   1, 0, 2,-1, 1, 0,   1,-1, 1, 0, 0,-1,  
     7  1,-1,-2, 2, 0, 0,   1, 2,-2, 1, 1, 0,   1,-4, 0, 3, 0, 0,  
     8  1,-1, 2, 0, 1, 0,   1, 3,-2, 0, 1, 0,   1, 2, 0,-1,-1, 0,  
     9  1, 0, 0, 1,-1, 0,   1,-2, 2, 1, 0, 0,   1, 4,-2,-1, 0, 0,  
     1  1,-3, 3, 0, 0,-1,   1,-2, 1, 1, 0,-1,   1,-2, 3,-1, 0,-1,  
     2  1, 0,-2, 1,-1, 0,   1,-2,-1, 1, 0, 1,   1, 4,-2, 1, 0, 0,  
     3  1,-4, 4,-1, 0, 0,   1,-4, 2, 1,-1, 0,   1, 5,-2, 0, 0, 0,  
     4  1, 3, 0,-2, 1, 0,   1,-5, 2, 2, 0, 0,   1, 2, 0, 1, 0, 0,  
     5  1, 1, 3, 0, 0,-1,   1,-2, 0, 1,-2, 0,   1, 4, 0,-1, 2, 0,  
     6  1, 1,-4, 0, 0, 2,   1, 5, 0,-2, 0, 0,   1,-1, 0, 2, 1, 0,  
     7  1,-2, 1, 0, 0, 0,   1, 4,-2, 1, 1, 0,   1,-3, 4,-2, 0, 0,  
     8  1,-1, 3, 0, 0,-1,   1, 3,-3, 0, 0, 1,   1, 5,-2, 0, 1, 0,  
     9  1, 1, 2, 0, 1, 0,   1, 2, 0, 1, 1, 0,   1,-5, 4, 0, 0, 0,  
     1  1,-2, 0,-1,-2, 0,   1, 5, 0,-2, 1, 0,   1, 1, 2,-2, 0, 0,  
     2  1, 1,-2, 2, 0, 0,   1,-2, 2, 1, 1, 0,   1, 0, 3,-1, 0,-1,  
     3  1, 2,-3, 1, 0, 1,   1,-2,-2, 3, 0, 0,   1,-1, 2,-2, 0, 0,  
     4  1,-4, 3, 1, 0,-1,   1,-4, 0, 3,-1, 0,   1,-1,-2, 2,-1, 0,  
     5  1,-2, 0, 3, 0, 0,   1, 4, 0,-3, 0, 0,   1, 0, 1, 1, 0,-1,  
     6  1, 2,-1,-1, 0, 1,   1, 2,-2, 1,-1, 0,   1, 0, 0,-1,-2, 0,  
     7  1, 2, 0, 1, 2, 0,   1, 2,-2,-1,-1, 0,   1, 0, 0, 1, 2, 0,  
     8  1, 0, 1, 0, 0, 0,   1, 2,-1, 0, 0, 0,   1, 0, 2,-1,-1, 0,  
     9  1,-1,-2, 0,-2, 0,   1,-3, 1, 0, 0, 1,   1, 3,-2, 0,-1, 0,  
     1  1,-1,-1, 0,-1, 1,   1, 4,-2,-1, 1, 0,   1, 2, 1,-1, 0,-1,  
     2  1, 0,-1, 1, 0, 1,   1,-2, 4,-1, 0, 0,   1, 4,-4, 1, 0, 0,  
     3  1,-3, 1, 2, 0,-1,   1,-3, 3, 0,-1,-1,   1, 1, 2, 0, 2, 0,  
     4  1, 1,-2, 0,-2, 0,   1, 3, 0, 0, 3, 0,   1,-1, 2, 0,-1, 0,  
     5  1,-2, 1,-1, 0, 1,   1, 0,-3, 1, 0, 1,   1,-3,-1, 2, 0, 1,  
     6  1, 2, 0,-1, 2, 0,   1, 6,-2,-1, 0, 0,   1, 2, 2,-1, 0, 0,  
     7  1,-1, 1, 0,-1,-1,   1,-2, 3,-1,-1,-1,   1,-1, 0, 0, 0, 2,  
     8  1,-5, 0, 4, 0, 0,   1, 1, 0, 0, 0,-2,   1,-2, 1, 1,-1,-1,  
     9  1, 1,-1, 0, 1, 1,   1, 1, 2, 0, 0,-2,   1,-3, 1, 1, 0, 0,  
     1  1,-4, 4,-1,-1, 0,   1, 1, 0,-2,-1, 0,   1,-2,-1, 1,-1, 1,  
     2  1,-3, 2, 2, 0, 0,   1, 5,-2,-2, 0, 0,   1, 3,-4, 2, 0, 0,  
     3  1, 1,-2, 0, 0, 2,   1,-1, 4,-2, 0, 0,   1, 2, 2,-1, 1, 0,  
     4  1,-5, 2, 2,-1, 0,   1, 1,-3, 0,-1, 1,   1, 1, 1, 0, 1,-1,  
     5  1, 6,-2,-1, 1, 0,   1,-2, 2,-1,-2, 0,   1, 4,-2, 1, 2, 0,  
     6  1,-6, 4, 1, 0, 0,   1, 5,-4, 0, 0, 0,   1,-3, 4, 0, 0, 0,  
     7  1, 1, 2,-2, 1, 0,   1,-2, 1, 0,-1, 0,   0, 2, 0, 0, 0, 0,  
     8  0, 1, 0,-1, 0, 0,   0, 0, 2, 0, 0, 0,   0, 0, 0, 0, 1, 0,  
     9  0, 2, 0, 0, 1, 0,   0, 3, 0,-1, 0, 0,   0, 1,-2, 1, 0, 0,  
     1  0, 2,-2, 0, 0, 0,   0, 3, 0,-1, 1, 0,   0, 0, 1, 0, 0,-1,  
     2  0, 2, 0,-2, 0, 0,   0, 2, 0, 0, 2, 0,   0, 3,-2, 1, 0, 0,  
     3  0, 1, 0,-1,-1, 0,   0, 1, 0,-1, 1, 0,   0, 4,-2, 0, 0, 0,  
     4  0, 1, 0, 1, 0, 0,   0, 0, 3, 0, 0,-1,   0, 4, 0,-2, 0, 0,  
     5  0, 3,-2, 1, 1, 0,   0, 3,-2,-1, 0, 0,   0, 4,-2, 0, 1, 0,  
     6  0, 0, 2, 0, 1, 0,   0, 1, 0, 1, 1, 0,   0, 4, 0,-2, 1, 0,  
     7  0, 3, 0,-1, 2, 0,   0, 5,-2,-1, 0, 0,   0, 1, 2,-1, 0, 0,  
     8  0, 1,-2, 1,-1, 0,   0, 1,-2, 1, 1, 0,   0, 2,-2, 0,-1, 0,  
     9  0, 2,-3, 0, 0, 1,   0, 2,-2, 0, 1, 0,   0, 0, 2,-2, 0, 0,  
     1  0, 1,-3, 1, 0, 1,   0, 0, 0, 0, 2, 0,   0, 0, 1, 0, 0, 1,  
     2  0, 1, 2,-1, 1, 0,   0, 3, 0,-3, 0, 0,   0, 2, 1, 0, 0,-1,  
     3  0, 1,-1,-1, 0, 1,   0, 1, 0, 1, 2, 0,   0, 5,-2,-1, 1, 0,  
     4  0, 2,-1, 0, 0, 1,   0, 2, 2,-2, 0, 0,   0, 1,-1, 0, 0, 0,  
     5  0, 5, 0,-3, 0, 0,   0, 2, 0,-2, 1, 0,   0, 1, 1,-1, 0,-1,  
     6  0, 3,-4, 1, 0, 0,   0, 0, 2, 0, 2, 0,   0, 2, 0,-2,-1, 0,  
     7  0, 4,-3, 0, 0, 1,   0, 3,-1,-1, 0, 1,   0, 0, 2, 0, 0,-2,  
     8  0, 3,-3, 1, 0, 1,   0, 2,-4, 2, 0, 0,   0, 4,-2,-2, 0, 0,  
     9  0, 3, 1,-1, 0,-1,   0, 5,-4, 1, 0, 0,   0, 3,-2,-1,-1, 0,  
     1  0, 3,-2, 1, 2, 0,   0, 4,-4, 0, 0, 0,   0, 6,-2,-2, 0, 0,  
     2  0, 5, 0,-3, 1, 0,   0, 4,-2, 0, 2, 0,   0, 2, 2,-2, 1, 0,  
     3  0, 0, 4, 0, 0,-2,   0, 3,-1, 0, 0, 0,   0, 3,-3,-1, 0, 1,  
     4  0, 4, 0,-2, 2, 0,   0, 1,-2,-1,-1, 0,   0, 2,-1, 0, 0,-1,  
     5  0, 4,-4, 2, 0, 0,   0, 2, 1, 0, 1,-1,   0, 3,-2,-1, 1, 0,  
     6  0, 4,-3, 0, 1, 1,   0, 2, 0, 0, 3, 0,   0, 6,-4, 0, 0, 0/
      k = 0
      nlp = 0
      ndi = 0
      nsd = 0
      do ll=1,nin
c  see if Doodson numbers match
         do kk=1,nt
            ii = 0
            do i=1,6
               ii = ii + iabs(idd(i,kk)-idtin(i,ll))
            enddo
            if(ii.eq.0) go to 5
         enddo
c  have a match - put line into array
 5       if(ii.eq.0.and.k.lt.ncon) then
            k = k + 1
            rl(k) = ampin(ll)*cos(dtr*phin(ll))/abs(tamp(kk))
            aim(k)= ampin(ll)*sin(dtr*phin(ll))/abs(tamp(kk))
c  Now have real and imaginary parts of admittance, scaled by C-E
c  amplitude. Admittance phase is whatever was used in the original
c  expression. (Usually phase is given relative to some reference
c  but amplitude is in absolute units). Next get frequency.
            call tdfrph(idd(1,kk),fr,pr)
            rf(k) = fr
         endif
      enddo
c  done going through constituents--there are k of them
c  have specified admittance at a number of points. sort these by frequency
c  and separate diurnal and semidiurnal, recopying admittances to get them in
c  order
      call shells(rf,key,k)
      do i=1,k
         if(rf(i).lt.0.5) nlp = nlp + 1
         if(rf(i).lt.1.5.and.rf(i).gt.0.5) ndi = ndi + 1
         if(rf(i).lt.2.5.and.rf(i).gt.1.5) nsd = nsd + 1
         scr(i) = rl(key(i))
      enddo
      do i=1,k
         rl(i) = scr(i)
         scr(i) = aim(key(i))
      enddo
      do i=1,k
         aim(i) = scr(i)
      enddo
c  now set up splines (8 cases - four species, each real and imag)
c  we have to allow for the case when there are no constituent amplitudes
c  for the long-period
c
      if(nlp.ne.0) call spline(nlp,rf,rl,zdr,scr)
      if(nlp.ne.0) call spline(nlp,rf,aim,zdi,scr)
      call spline(ndi,rf(nlp+1),rl(nlp+1),dr,scr)
      call spline(ndi,rf(nlp+1),aim(nlp+1),di,scr)
      call spline(nsd,rf(nlp+ndi+1),rl(nlp+ndi+1),sdr,scr)
      call spline(nsd,rf(nlp+ndi+1),aim(nlp+ndi+1),sdi,scr)
c  evaluate all harmonics using the interpolated admittance
      j = 1
      do i=1,nt
         if(idd(1,i).eq.0.and.nlp.eq.0) go to 11
         call tdfrph(idd(1,i),f(j),p(j))
c  phase corrections to equilibrium tide
         if(idd(1,i).eq.0) p(j) = p(j) + 180.
         if(idd(1,i).eq.1) p(j) = p(j) + 90.
         sf = f(j)
         if(idd(1,i).eq.0) re = eval(sf,nlp,rf,rl,zdr)
         if(idd(1,i).eq.0) am = eval(sf,nlp,rf,aim,zdi)
         if(idd(1,i).eq.1) re = eval(sf,ndi,rf(nlp+1),rl(nlp+1),dr)
         if(idd(1,i).eq.1) am = eval(sf,ndi,rf(nlp+1),aim(nlp+1),di)
         if(idd(1,i).eq.2) re =
     1      eval(sf,nsd,rf(nlp+ndi+1),rl(nlp+ndi+1),sdr)
         if(idd(1,i).eq.2) am =
     1      eval(sf,nsd,rf(nlp+ndi+1),aim(nlp+ndi+1),sdi)
         amp(j) = tamp(i)*sqrt(re**2+am**2)
         p(j) = p(j) + atan2(am,re)/dtr
         if(p(j).gt.180) p(j)=p(j)-360.
         j = j + 1
 11      continue
      enddo
      nout = j - 1
      return
      end
c=============================================================================
      subroutine etutc(year,delta)
c
c   Input is year (decimal) 1700-2008.5
c   Output is delta: et - utc in seconds
c   Tables from p. 90, Explanatory Supplement to the A.E. & N.A;
c   Dr. R A Broucke, JPL; and the leap.sec table in GAMIT
c   UTC (and UT) is the time usually used (eg in time signals)
c
c   ====>>> To add leap seconds update nstep, and the arrays st, and si
c
      parameter (nstep=24)
      integer i,n,nstep
      real d,delta,frac,st,si,tx,ty,year
      dimension d(142),tx(39),ty(39),st(nstep),si(nstep)
c
c si gives amount of step, at the times given in st
c
      data si/24*1./
      data st/1972.5,1973.0,1974.0,1975.0,1976.0,1977.0,1978.0,
     1        1979.0,1980.0,1981.5,1982.5,1983.5,1985.5,1988.0,
     2        1990.0,1991.0,1992.5,1993.5,1994.5,1996.0,1997.5,
     3        1999.0,2006.0,2009.0/
c
      data d/ 5.15, 4.64, 5.36, 3.49, 3.27, 2.45, 4.03, 1.76, 3.30,
     1  1.00, 2.42, 0.94, 2.31, 2.27,-0.22, 0.03,-0.05,-0.06,-0.57,
     2  0.03,-0.47, 0.98,-0.86, 2.45, 0.22, 0.37, 2.79, 1.20, 3.52,
     3  1.17, 2.67, 3.06, 2.66, 2.97, 3.28, 3.31, 3.33, 3.23, 3.60,
     4  3.52, 4.27, 2.68, 2.75, 2.67, 1.94, 1.39, 1.66, 0.88, 0.33,
     5 -0.17,-1.88,-3.43,-4.05,-5.77,-7.06,-7.36,-7.67,-7.64,-7.93,
     6 -7.82,-8.35,-7.91,-8.03,-9.14,-8.18,-7.88,-7.62,-7.17,-8.14,
     7 -7.59,-7.17,-7.94,-8.23,-7.88,-7.68,-6.94,-6.89,-7.11,-5.87,
     8 -5.04,-3.90,-2.87,-0.58, 0.71, 1.80, 3.08, 4.63, 5.86, 7.21,
     9  8.58,10.50,12.10,12.49,14.41,15.59,15.81,17.52,19.01,18.39,
     1 19.55,20.36,21.01,21.81,21.76,22.35,22.68,22.94,22.93,22.69,
     2 22.94,23.20,23.31,23.63,23.47,23.68,23.62,23.53,23.59,23.99,
     3 23.80,24.20,24.99,24.97,25.72,26.21,26.37,26.89,27.68,28.13,
     4 28.94,29.42,29.66,30.29,30.96,31.09,31.59,32.06,31.82,32.69,
     5 33.05,33.16,33.59/
      data tx/61.5,
     262.     ,62.5     ,63.      ,63.5     ,64.      ,64.5     ,65.   ,
     365.5    ,66.      ,66.5     ,67.      ,67.5     ,68.      ,68.25 ,
     468.5    ,68.75    ,69.      ,69.25    ,69.5     ,69.75    ,70.   ,
     570.25   ,70.5     ,70.75    ,71.      ,71.085   ,71.162   ,71.247,
     671.329  ,71.414   ,71.496   ,71.581   ,71.666   ,71.748   ,71.833,
     771.915  ,71.999   ,72.0/
      data ty/33.59,
     234.032  ,34.235   ,34.441   ,34.644   ,34.95    ,35.286   ,35.725,
     336.16   ,36.498   ,36.968   ,37.444   ,37.913   ,38.39    ,38.526,
     438.76   ,39.      ,39.238   ,39.472   ,39.707   ,39.946   ,40.185,
     540.42   ,40.654   ,40.892   ,41.131   ,41.211   ,41.284   ,41.364,
     641.442  ,41.522   ,41.600   ,41.680   ,41.761   ,41.838   ,41.919,
     741.996  ,42.184   ,42.184/
c
c  for oldest epochs, use approximations
c
      if(year.lt.1700.) then
        delta = 0.
        return
      endif
      if(year.lt.1785.) then
        delta = (year-1750.)/5.
        return
      endif
      if(year.lt.1820.5) then
        delta = 6.
        return
      endif
c
c   for 1820.5 to 1961.5, data is spaced at yearly intervals
c
      if(year.lt.1961.5) then
         n = year - 1819.5
         frac = year - (1819.5 + n)
         delta = (d(n+1) - d(n))*frac + d(n)
         return
      endif
c
c   for 1961.5 to 1972.0, interpolate between unequispaced data
c
      if(year.lt.1972) then
        do i = 1,38
           if(year-1900..eq.tx(i)) then
              delta = ty(i)
              return
           endif
           if(year-1900..lt.tx(i)) then
              delta=ty(i-1) + (ty(i)-ty(i-1))*
     1                ((year-1900.-tx(i-1))/(tx(i)-tx(i-1)))
              return
           endif
        enddo
      endif
c
c   after 1972 et-utc has only step offsets. st is the array of step times,
c   si the step sizes (an added second is +1.)
c
      delta = 42.184
      do i = 1,nstep
         if(year.ge.st(i)) delta = delta + si(i)
         if(year.lt.st(i)) return
      enddo
      return
      end
c=============================================================================
      real function eval(y,nn,x,u,s)
c
c$$$$ calls no other routines
c  performs cubic spline interpolation of a function sampled at unequally
c  spaced intervals.  the routine spline  should be called to set up the array s
c  y  the coordinate at which function value is desired.
c  nn  number of samples of original function.
c  x  array containing sample coordinates. the sequence x(1),x(2).....x(nn)
c     must be strictly increasing.
c  u  array containing samples of function at the coordinates x(1),x(2)...
c  s  array containing the 2nd derivatives at the sample points.  found by the
c     routine  spline, which must be called once before beginning interpolation.
c  if  y  falls outside range(x(1),x(nn))  the value at the nearest endpoint
c  of the series is used.
c
      integer k,k1,k2,nn
      real deli,dk,dy,dy1,f1,f2,f3,ff1,ff2,s,u,x,y
      dimension x(*),u(*),s(*)
      nn=iabs(nn)
c  if out of range, substitute end values.
      if (y.le.x(1)) then
         eval=u(1)
         return
      endif
      if (y.ge.x(nn)) then
         eval=u(nn)
         return
      endif
c  locate interval (x(k1),x(k2))  containing y
      do k=2,nn
         if(x(k-1).lt.y.and.x(k).ge.y) then
           k1=k-1
           k2=k
         endif
      enddo
c  evaluate interpolate
      dy=x(k2)-y
      dy1=y-x(k1)
      dk=x(k2)-x(k1)
      deli=1./(6.0*dk)
      ff1=s(k1)*dy*dy*dy
      ff2=s(k2)*dy1*dy1*dy1
      f1=(ff1+ff2)*deli
      f2=dy1*((u(k2)/dk)-(s(k2)*dk)/6.0)
      f3= dy*((u(k1)/dk)-(s(k1)*dk)/6.0)
      eval=f1+f2+f3
      return
      end
c=============================================================================
      integer function juldat(it)
c
c  Julian Date from Gregorian date, Algorithm from p. 604, Explanatory
c    Supplement Amer Ephemeris & Nautical Almanac (cf Comm CACM, 11, 657 (1968)
c    and 15, 918 (1972)) Valid for all positive values of Julian Date
c
      integer it
      dimension it(*)
      juldat=(1461*(it(1)+4800+(it(2)-14)/12))/4
     1     + (367*(it(2)-2-12*((it(2)-14)/12)))/12
     2     - (3*((it(1)+4900+(it(2)-14)/12)/100))/4+it(3)-32075
      return
      end
c=============================================================================
      integer function leap(iy)
c
c returns 1 if year is a leap year, by Clavian (Gregorian) rule
c
      integer iy
      leap = 1 - (mod(iy,4)+3)/4
      if(mod(iy,100).eq.0.and.mod(iy,400).ne.0) leap=0
      return
      end
c=============================================================================
      integer function mday(iy,m)
c
c  finds day number of day before start of month m, of year iy, in
c   Gregorian intercalation
c
      integer iy,leap,m
      leap = 1 - (mod(iy,4)+3)/4
      if(mod(iy,100).eq.0.and.mod(iy,400).ne.0) leap=0
      mday = mod((367*(m-2-12*((m-14)/12)))/12+29,365) + leap*((9+m)/12)
      return
      end
c=============================================================================
      subroutine recurs(x,n,hc,nf,om,scr)
c
c  does sin and cos recursion to fill in data x, of length n, for
c  nf sines and cosines with frequenciies om (normalized so the
c  nyquist is pi). hc contains alternating cosine and sine coefficients
c  scr is a scratch array of length 3*nf (n.b. - it is double precision)
c
      integer i,j,n,nf
      real x,hc,om
      double precision sc,scr
      dimension x(*),hc(*),scr(*),om(*)
c  set up for start of recursion by computing harmonic values
c  at start point and just before it
      do i = 1,nf
         scr(3*i-2) = hc(2*i-1)
         scr(3*i-1) = hc(2*i-1)*cos(om(i)) -hc(2*i)*sin(om(i))
         scr(3*i) = 2.*dcos(dble(om(i)))
      enddo
c  do recursion over data
      do i = 1,n
         x(i) = 0.
c  do recursive computation for each harmonic
         do j  = 1,nf
            x(i) = x(i) + scr(3*j-2)
            sc = scr(3*j-2)
            scr(3*j-2) = scr(3*j)*sc-scr(3*j-1)
            scr(3*j-1) = sc
         enddo
      enddo
      return
      end
c=============================================================================
      subroutine shells(x,k,n)
c  sorts an array x, of length n, sorting upward, and returns
c  an array k which may be used to key another array to the
c  sorted pattern (i.e., if we had an array f to which x
c  corresponded before sorting, then after calling shells,
c  f(k(1)) will be the element of f corresponding to the
c  smallest x, f(k(2)) the next smallest, and so on.
c   revised 29-dec-82 so k is sorted in turn, the values of
c  k that point to identical values of x being put in increasing
c  order
c
c    calls no other routines
c
      integer i,igap,iex,ik,imax,ipl,j,k,l,n
      real sv,x
      dimension x(n),k(n)
      igap = n
      do 1 i = 1,n
 1    k(i) = i
 5    if(igap.le.1) go to 25
      igap = igap/2
      imax = n - igap
 10   iex = 0
      do 20 i = 1,imax
      ipl = i + igap
      if(x(i).le.x(ipl)) go to 20
      sv = x(i)
      ik = k(i)
      x(i) = x(ipl)
      k(i) = k(ipl)
      x(ipl) = sv
      k(ipl) = ik
      iex = iex + 1
 20   continue
      if(iex.gt.0) go to 10
      go to 5
c
c  now sort k's (for identical values of x, if any)
c
 25   j = 1
 30   if(j.ge.n) return
      if(x(j).eq.x(j+1)) go to 33
      j = j + 1
      go to 30
c  have at least two x's with the same value - see how long this is true
 33   l = j
 35   if(x(l).ne.x(l+1)) go to 38
      l = l + 1
      if(l.lt.n) go to 35
c  j and l are the indices within which x(i) does not change - sort k
 38   igap = l - j + 1
 40   if(igap.le.1) j = l + 1
      if(igap.le.1) go to 30
      igap = igap/2
      imax = l-j+1 - igap
 45   iex = 0
      do 50 i=1,imax
      ipl = i + igap + j - 1
      if(k(i+j-1).le.k(ipl)) go to 50
      ik = k(i+j-1)
      k(i+j-1) = k(ipl)
      k(ipl) = ik
      iex = iex + 1
 50   continue
      if(iex.gt.0) go to 45
      go to 40
      end
c=============================================================================
      subroutine spline(nn,x,u,s,a)
c
c$$$$ calls no other routines
c  finds array  s  for spline interpolator  eval.
c  nn  number of data points supplied (may be negative, see below)
c  x  array containing x-coordinates where function is sampled.  xx(1),xx(2),...
c     must be a strictly increasing sequence.
c  u  array containing sample values that are to be interpolated.
c  s  output array of 2nd derivative at sample points.
c  a  working space array of dimension at least  nn.
c  if the user wishes to force the derivatives at the ends of the series to
c  assume specified values, he should put du(1)/dx and du(n)/dx in s1,s2
c  and call the routine with nn=-number of terms in series.  normally a parabola
c  is fitted through the 1st and last 3 points to find the slopes.
c  if less than 4 points are supplied, straight lines are fitted.
c
      integer i,j,n,n1,nn
      real a,c,q,q1,qn,s,u,x
      dimension x(*),u(*),s(*),a(*)
c
      q(u1,x1,u2,x2)=(u1/x1**2-u2/x2**2)/(1.0/x1-1.0/x2)
c
      n=iabs(nn)
      if (n.le.3) then
c  series too short for cubic spline - use straight lines.
         do i=1,n
            s(i)=0.0
         enddo
         return
      endif
      q1=q(u(2)-u(1),x(2)-x(1),u(3)-u(1),x(3)-x(1))
      qn=q(u(n-1)-u(n),x(n-1)-x(n),u(n-2)-u(n),x(n-2)-x(n))
      if (nn.le.0) then
         q1=s(1)
         qn=s(2)
      endif
      s(1)=6.0*((u(2)-u(1))/(x(2)-x(1)) - q1)
      n1= n - 1
      do i=2,n1
         s(i)= (u(i-1)/(x(i)-x(i-1)) - u(i)*(1.0/(x(i)-x(i-1))+
     +    1.0/(x(i+1)-x(i))) + u(i+1)/(x(i+1)-x(i)))*6.0
      enddo
      s(n)=6.0*(qn + (u(n1)-u(n))/(x(n)-x(n1)))
      a(1)=2.0*(x(2)-x(1))
      a(2)=1.5*(x(2)-x(1)) + 2.0*(x(3)-x(2))
      s(2)=s(2) - 0.5*s(1)
      do i=3,n1
         c=(x(i)-x(i-1))/a(i-1)
         a(i)=2.0*(x(i+1)-x(i-1)) - c*(x(i)-x(i-1))
         s(i)=s(i) - c*s(i-1)
      enddo
      c=(x(n)-x(n1))/a(n1)
      a(n)=(2.0-c)*(x(n)-x(n1))
      s(n)=s(n) - c*s(n1)
c  back substitiute
      s(n)= s(n)/a(n)
      do j=1,n1
         i=n-j
         s(i) =(s(i) - (x(i+1)-x(i))*s(i+1))/a(i)
      enddo
      return
      end
c=============================================================================
      subroutine tdfrph(idood,freq,phase)
c
c   Given the Doodson number of a tidal constituent (in idood), returns
c  the frequency and phase.  Phase is returned in degrees and frequency
c  in cycles/day.
c
c   Note that phases must be decreased by 90 degrees if the sum of the order
c  and the species number is odd (as for the 2nd degree diurnals, and 3rd
c  degree low-frequency and semidiurnals).
c   These phases may need further adjustment to allow for the spherical
c  harmonic normalization used; e.g. for that used for the potential by
c  Cartwright and Tayler, 180 degrees must be added for (species,order)
c  = (1,2), (1,3), or (3,3).
c
c  Common block date stores time information, in UT
c
c    calls toymd, leap, juldat, etutc (all for timekeeping)
c
      save itmsave,d,dd
      integer i,idood,initial,itm,itm2,itmsave,jd
      real year,delta
      double precision freq,phase
      double precision d,dayfr,dd,djd,f1,f2,f3,f4,f5,
     1                               fd1,fd2,fd3,fd4,fd5,t
      dimension idood(6),itm2(6),itmsave(5),d(6),dd(6)
      common/date/itm(5)
      data itmsave/5*0/
c
c  test to see if time has changed; if so, set the phases and frequencies
c   for each of the Doodson arguments
c
      initial=0
      do i=1,5
        if(itm(i).ne.itmsave(i)) initial=1
      enddo
      if(initial.eq.1) then
        do i=1,5
           itmsave(i) = itm(i)
        enddo
c
c convert times to Julian days (UT) then to Julian centuries from J2000.00
c   (ET)
c
        call toymd(itm,itm2)
        jd = juldat(itm2)
        dayfr=  itm(3)/24.d0 + itm(4)/1440.d0 + itm(5)/84600.d0
        year=itm(1)+(itm(2)+dayfr)/(365+leap(itm(1)))
        call etutc(year,delta)
        djd= jd - 0.5d0 + dayfr
        t = (djd - 2451545.0d0 + delta/86400.d0)/36525.d0
c
c IERS expressions for the Delauney arguments, in degrees
c
        f1 =     134.9634025100d0 +
     1    t*( 477198.8675605000d0 +
     1    t*(      0.0088553333d0 +
     1    t*(      0.0000143431d0 +
     1    t*(     -0.0000000680d0 ))))
        f2 =     357.5291091806d0 +
     1    t*(  35999.0502911389d0 +
     1    t*(     -0.0001536667d0 +
     1    t*(      0.0000000378d0 +
     1    t*(     -0.0000000032d0 ))))
        f3 =      93.2720906200d0 +
     1    t*( 483202.0174577222d0 +
     1    t*(     -0.0035420000d0 +
     1    t*(     -0.0000002881d0 +
     1    t*(      0.0000000012d0 ))))
        f4 =     297.8501954694d0 +
     1    t*( 445267.1114469445d0 +
     1    t*(     -0.0017696111d0 +
     1    t*(      0.0000018314d0 +
     1    t*(     -0.0000000088d0 ))))
        f5 =     125.0445550100d0 +
     1    t*(  -1934.1362619722d0 +
     1    t*(      0.0020756111d0 +
     1    t*(      0.0000021394d0 +
     1    t*(     -0.0000000165d0 ))))
c
c  convert to Doodson (Darwin) variables
c
        d(1) = 360.d0*dayfr - f4
        d(2) = f3 + f5
        d(3) = d(2) - f4
        d(4) = d(2) - f1
        d(5) = -f5
        d(6) = d(3) - f2
c
c   find frequencies of Delauney variables (in cycles/day), and from these
c    the same for the Doodson arguments
c
        fd1 =  0.0362916471 + 0.0000000013*t
        fd2 =  0.0027377786
        fd3 =  0.0367481951 - 0.0000000005*t
        fd4 =  0.0338631920 - 0.0000000003*t
        fd5 = -0.0001470938 + 0.0000000003*t
        dd(1) = 1.d0 - fd4
        dd(2) = fd3 + fd5
        dd(3) = dd(2) - fd4
        dd(4) = dd(2) - fd1
        dd(5) = -fd5
        dd(6) = dd(3) - fd2
      endif
c
c   end of intialization (likely to be called only once)
c
c  compute phase and frequency of the given tidal constituent
c
      freq=0.d0
      phase=0.d0
      do i = 1,6
         freq =   freq + idood(i)*dd(i)
         phase = phase + idood(i)*d(i)
      enddo
c adjust phases to fall in the positive range 0 to 360
      phase = dmod(phase,360.d0)
      if(phase.lt.0.d0) phase = phase + 360.d0
      return
      end
c=============================================================================
      subroutine toymd(it1,it2)
      integer idn,it1,it2,jj,m,mon
      dimension it1(*),it2(*)
c
c  converts times in it1 given as year and day to year-month-day in it2
c
      idn(m) = mod((367*(m-2-12*((m-14)/12)))/12+29,365)
      mon(jj,m) = (12*(jj-29-m))/367 + 2 + (jj-200)/169
      it2(1)=it1(1)
      it2(2)=mon(it1(2),leap(it1(1)))
      it2(3) = it1(2) - idn(it2(2)) - leap(it2(1))*((9+it2(2))/12)
      return
      end
*+----------------------------------------------------------------------
*
*  Copyright (C) 2009
*  IERS Conventions center
*
*  ========================================
*  IERS Conventions center Software License
*  ========================================
*
*  NOTICE TO USER:
*
* BY USING THIS SOFTWARE YOU ACCEPT THE FOLLOWING TERMS AND CONDITIONS
* WHICH APPLY TO ITS USE.
*
* 1. The Software is provided by the IERS Conventions Center ("the
* Center").
*
* 2. Permission is granted to anyone to use the Software for any
* purpose, including commercial applications, free of charge,
* subject to the conditions and restrictions listed below.
*
* 3. You (the user) may adapt the Software and its algorithms for your
* own purposes and you may distribute the resulting "derived work"
* to others, provided that the derived work complies with the
* following requirements:
*
* a) Your work shall be clearly identified so that it cannot be
* mistaken for IERS Conventions software and that it has been
* neither distributed by nor endorsed by the Center.
*
* b) Your work (including source code) must contain descriptions of
* how the derived work is based upon and/or differs from the
* original Software.
*
* c) The name(s) of all modified routine(s) that you distribute
* shall be changed.
*
* d) The origin of the IERS Conventions components of your derived
* work must not be misrepresented; you must not claim that you
* wrote the original Software.
*
* e) The source code must be included for all routine(s) that you
* distribute. This notice must be reproduced intact in any
* source distribution.
*
* 4. The Software is provided to the user "as is" and the Center makes
* no warranty as to its use or performance.   The Center does not
* and cannot warrant the performance or results which the user may
* obtain by using the Software.  The Center makes no warranties,
* express or implied, as to non-infringement of third party rights,
* merchantability, or fitness for any particular purpose.  In no
* event will the Center be liable to the user for any consequential,
* incidental, or special damages, including any lost profits or lost
* savings, even if a Center representative has been advised of such
* damages, or for any claim by any third party.
*
*  Correspondence concerning IERS Conventions software should be
*  addressed to gpetit[at]bipm.org or brian.luzum[at]usno.navy.mil
*
*-----------------------------------------------------------------------

